0x00
操作系统中，访问内存时，提供了两种模式。一种是实模式，直接访问物理地址。

在8086处理器中，一个地址有段和偏移两部分组成，物理地址的计算公式为：
　　　物理地址（physicaladdress）=段值（segment） * 16 + 偏移（offset）
其中，segment和offset都是16位的。

最开始的程序寻址是直接的“段：偏移”模式，这样的好处是所见即所得，程序员指定的地址就是物理地址，物理地址对程序员是可见的。
这就带来一些问题：1）无法支持多任务2）程序的安全性无法得到保证。

一种是保护模式，程序给出段地址和偏移量来访问内存。

保护模式下，虽然段值仍然由原来的cs、ds等寄存器表示，但此时它仅仅变成了一个索引，这个索引指向了一个数据结构的一个表项。
表项中详细定义了段的起始地址、界限、属性等内容。这个数据结构就是全局描述符GDT或者局部描述符LDT。

若想理解操作系统程序中的启动相关的部分，必须要理解保护模式下的编程，而分段机制是保护模式编程下的基础。
而且，由于实模式与保护模式的不同，对保护模式下的分段机制更需要注意。


0x01线性地址
传统上，段地址和偏移地址称为逻辑地址，偏移地址叫做有效地址，在指令中给出有效地址的方式叫做寻址方式。

段的管理是由处理器的段部件负责进行的，段部件将段地址和偏移地址相加，得到访问内存的地址。一般来说，段部件产生的地址就是物理地址。

在分段模型下，内存的分配是不定长的，时间长了，内存空间就会碎片化，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务。

为了解决这个问题，在支持分页功能后，分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的，一般为 4KB，通过使用页，可以简化内存管理。

当页功能开启时，段部件产生的地址就不再是物理地址了，而是线性地址，线性地址还要经页部件转换后，才是物理地址。
当页n功能关闭时，线性地址就是物理地址。


0x02描述符
GDTR全局描述符寄存器：48位，高32位存放GDT基址，低16为存放GDT限长。

LDTR局部描述符寄存器：16位，高13为存放LDT在GDT中的索引值。

保护模式下的段寄存器 由 16位的选择器 与 64位的段描述符寄存器 构成。

段选择器（段选择子）:32位汇编中16位段寄存器(CS、DS、ES、SS、FS、GS)中不再存放段基址,而是段描述符在段描述符表中的索引值。
D3-D15位是索引值,D0-D1位是优先级(RPL)用于特权检查,D2位是描述符表引用指示位TI。
TI=0指示从全局描述表GDT中读取描述符，TI=1指示从局部描述符中LDT中读取描述符。


0x03IA-32处理器全局寻段
① 先从GDTR寄存器中的高32位，获得GDT基址。
② 然后从段寄存器中的前16位的，段选择器中高13位，位置索引值得到段描述符。
③ 段描述符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。


0x04A-32处理器局部寻段
① 先从GDTR寄存器中的高32位，获得GDT基址。
② 从LDTR寄存器中的高13位，获取LDT所在GDT段的，位置索引。
③ 然后这个位置索引在GDT中，得到此LDT段描述符从而得到，指定LDT段基址。
④ 再用段选择器高13位位置索引，从LDT段中得到段描述符。
⑤ 段描述符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。



